# ADR-003: Google Wire for Dependency Injection

## Status

**Accepted** - 2025-11-22

## Context

Our hexagonal architecture requires injecting dependencies (repositories, services, config) into various components. We need a dependency injection solution that:

- Works well with Go's static typing
- Provides compile-time safety
- Has minimal runtime overhead
- Is easy to understand and debug
- Supports complex dependency graphs

Options considered:
1. Manual dependency injection (constructors)
2. Google Wire (compile-time code generation)
3. Uber Fx (reflection-based runtime DI)
4. dig (reflection-based runtime DI)

## Decision

We will use **Google Wire** for dependency injection.

Wire generates Go code at compile time to wire dependencies together. It uses a declarative approach where you define "providers" (functions that create dependencies) and Wire generates the initialization code.

### Implementation

**Provider Functions** (`internal/wire/providers.go`):
```go
func ProvideConfig(path string) (*config.Config, error) {
    return config.Load(path)
}

func ProvideLogger(cfg *config.Config) *logger.Logger {
    return logger.New(cfg.App.LogLevel, os.Stdout)
}

func ProvideUserService(repo ports.UserRepository) ports.UserService {
    return service.NewUserService(repo)
}
```

**Wire Injector** (`cmd/api/wire.go`):
```go
//go:build wireinject

func initializeApp(configPath string) (*gin.Engine, func(), error) {
    wire.Build(wireproviders.ProviderSet)
    return nil, nil, nil
}
```

**Generated Code** (`cmd/api/wire_gen.go`):
```go
// Code generated by Wire. DO NOT EDIT.
func initializeApp(configPath string) (*gin.Engine, func(), error) {
    config := wire.ProvideConfig(configPath)
    logger := wire.ProvideLogger(config)
    db, cleanup := wire.ProvidePostgresDB(config, logger)
    repo := wire.ProvideUserRepository(db)
    service := wire.ProvideUserService(repo)
    engine := wire.ProvideGinEngine(service)
    return engine, cleanup, nil
}
```

## Consequences

### Positive

✅ **Compile-Time Safety**
- Missing dependencies caught at compile time
- Type mismatches detected early
- No runtime surprises

✅ **Zero Runtime Overhead**
- Generated code is plain Go
- No reflection or runtime container
- Same performance as manual DI

✅ **Clear Dependency Graphs**
- Easy to see what depends on what
- Generated code is readable
- Debugging is straightforward

✅ **Refactoring Support**
- Compiler catches broken dependencies
- IDEs can follow dependency chains
- Safe to rename or move components

✅ **Explicit Over Implicit**
- All dependencies are visible in provider functions
- No magic or hidden behavior
- Easy for new developers to understand

### Negative

⚠️ **Code Generation Step**
- Need to run `wire` command after changes
- Generated files added to `.gitignore`
- Adds build step to workflow

⚠️ **Build Tag Constraints**
- Need `//go:build wireinject` tags
- Two versions of injector (definition and generated)
- Can be confusing initially

⚠️ **Limited Dynamic Behavior**
- All wiring happens at compile time
- Cannot conditionally inject based on runtime config
- May need manual factory functions for some cases

### Mitigations

- Integrate Wire generation into Taskfile (`task wire:generate`)
- Document the wire generation process clearly
- Provide examples in the codebase (User feature)
- Use cleanup functions for resource management

## Alternatives Considered

### 1. Manual Dependency Injection

**Approach**: Write initialization code manually in `main.go`

```go
func main() {
    cfg := config.Load("config.yaml")
    log := logger.New(cfg.LogLevel)
    db := database.NewPostgres(cfg, log)
    userRepo := postgres.NewUserRepository(db)
    userService := service.NewUserService(userRepo)
    // ... many more lines
}
```

**Pros**:
- No tooling required
- Complete control
- Easy to understand

**Cons**:
- Error-prone for complex graphs
- Tedious to maintain
- No compile-time validation of completeness
- Hard to test initialization logic

**Why Rejected**: Doesn't scale well; too error-prone for our needs

### 2. Uber Fx (Runtime DI)

**Approach**: Reflection-based DI container at runtime

```go
app := fx.New(
    fx.Provide(
        config.Load,
        logger.New,
        database.NewPostgres,
        // ...
    ),
    fx.Invoke(startServer),
)
```

**Pros**:
- Powerful runtime features (lifecycle hooks, decorators)
- Can inject based on runtime conditions
- Popular in Go ecosystem

**Cons**:
- Runtime reflection overhead
- Errors only at runtime
- Harder to debug (stack traces through reflection)
- More complex mental model

**Why Rejected**: Runtime reflection overhead; we prefer compile-time safety

### 3. dig (Uber's DI Library)

Similar to Fx but lower level.

**Why Rejected**: Same concerns as Fx regarding runtime reflection

## Implementation Notes

### Provider Organization

Providers are organized by layer:
```go
var ProviderSet = wire.NewSet(
    // Infrastructure
    ProvideConfig,
    ProvideLogger,
    ProvideHealthChecker,
    ProvidePostgresDB,

    // Domain services
    ProvideUserRepository,
    ProvideUserService,

    // HTTP server
    ProvideGinEngine,
)
```

### Cleanup Functions

Providers can return cleanup functions:
```go
func ProvidePostgresDB(...) (*gorm.DB, func(), error) {
    db, err := database.NewPostgresDB(cfg, log)
    cleanup := func() {
        sqlDB, _ := db.DB()
        sqlDB.Close()
    }
    return db, cleanup, err
}
```

### Testing

For tests, bypass Wire and inject mocks manually:
```go
func TestUserService(t *testing.T) {
    mockRepo := new(mocks.MockUserRepository)
    service := service.NewUserService(mockRepo)
    // Test with mock
}
```

## References

- [Google Wire Documentation](https://github.com/google/wire)
- [Wire User Guide](https://github.com/google/wire/blob/main/docs/guide.md)
- [Wire Best Practices](https://github.com/google/wire/blob/main/docs/best-practices.md)
